# -*- coding: utf-8 -*-
"""PS1_PE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GqMYh7aI-WjVa3xHuIslcReHek7wmDHn

<h2>Trabajo de Simulación 1</h2>
<br/>
<p><u>Grupo 7. Los Asintóticos:</u> Erlich, Raisa - Chiaradía, Isabella - Lucero, Yesica - Pacheco, Franco - Vargas, Emiliano - Santarelli, Hernán.</p>

<i>Para facilidad en la ejecución del código, hemos colocado comentarios a lo largo del mismo para indicar qué bullet se está desarrollando en cada sección</i>
<br/><br/>
1- Para el armado del bullet "1. Experimento aleatorio", definir la función cumples(k), que devuelva k fechas de cumpleaños (k números entre 1 y 365).
<br/>2- Para el armado del bullet "2: Muestra aleatoria", definir una semilla, fijar N y armar N=1000 muestras de cumples(k) que se guarden en muestras.
<br/>3- Para el armado del bullet "3: Una función filtro que caracteriza el evento E", definir la función hay_coincidencia(cumples) que devuelva TRUE (o un 1) si hay una coincidencia en una lista cumples que sea pasada como argumento. Esta es la función que quizás sea más difícil de implementar. Hay muchas formas de hacerlo. Como pista, la función set() que ya usamos es una estructura de datos ideal para contener objetos sin repeticiones.
<br/>4- Para el armado del bullet "4: Aproximamos P(E) por la proporción de elementos de E en la muestra" contar la proporción de hay_coincidencia() en las N repeticiones de la muestra y devolver ese valor.
"""

# Importamos las librerias que vamos a utilizar
import random
import matplotlib.pyplot as plt

#########################################
# Probabilidad estimada de coincidencia #
#########################################

# 2- Definimos una semilla en la que vamos a trabajar
random.seed(95)

# 1- Definimos la función para generar fechas de cumpleaños aleatorias (números entre 1 y 365)
def cumples(k):
    return [random.randint(1, 365) for _ in range(k)]



# 2- Fijamos N=1000 muestras de cumples(k) que se guarden en muestras.
muestras = []
N = 1000

# 3: Una función filtro que caracteriza el evento E:
# Se define la función hay_coincidencia(cumples) para verificar si hay coincidencia en las fechas de cumpleaños
def hay_coincidencia(cumples):
    cumples_conjunto = set(cumples)
    return len(cumples) != len(cumples_conjunto)

# 4: Aproximamos P(E) por la proporción de elementos de E en la muestra"
# Definimos la función para estimar la probabilidad de coincidencia de cumpleaños para un grupo de k personas
def estimar_probabilidad(k, N):
    coincidencias = 0
    for _ in range(N):
        muestras = cumples(k)
        if hay_coincidencia(muestras):
            coincidencias += 1
    return coincidencias / N


# Calcular las probabilidades estimadas para k de 1 a 50
k_values = list(range(1, 51))
probabilidades_estimadas = [estimar_probabilidad(k, N) for k in k_values]

# Calculamos la probabilidad estimada para k = 23
probabilidad_k_23 = probabilidades_estimadas[22]

# Demostramos con gráficos
# Gráfico de la probabilididad estimada de la paradoja del cumpleaños
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)  # Crear un subplot de 1 fila y 2 columnas, y seleccionar el primer gráfico
plt.plot(k_values, probabilidades_estimadas, marker='o', linestyle='-', color='b')
plt.xlabel('Cantidad de Personas (k)')
plt.ylabel('Probabilidad Estimada')
plt.title('Probabilidad de Coincidencia de Cumpleaños')
plt.grid(True)
plt.xticks(range(1, 51, 2))  # Mostrar valores eje x de 1 a 50 de 2 en 2

# Agregamos una flecha que muestre el resultado en k = 23
plt.annotate(f'P(k=23) = {probabilidad_k_23:.4f}', xy=(23, probabilidad_k_23), xytext=(28, 0.1),
             arrowprops=dict(facecolor='black', shrink=0.05))

######################################################
# Probabilidad teórica de la Paradoja del Cumpleaños #
######################################################

# Definimos la función para calcular la probabilidad de la paradoja del cumpleaños
def calculoParadoja(x):
    dias = 365
    y = dias**x
    casos = 1
    for i in range(dias, dias - x, -1):
        casos *= i

    probaC = casos / y
    probabilidad = 1 - probaC
    return probabilidad

# Calcular las probabilidades de la paradoja del cumpleaños para x (cantidad de personas) de 1 a 50
cantidad_personas = list(range(1, 51))
probabilidad_real = [calculoParadoja(x) for x in cantidad_personas]

# Gráfico de la probabilidad teórica de la paradoja del cumpleaños
plt.subplot(1, 2, 2)  # Seleccionar el segundo gráfico
plt.plot(cantidad_personas, probabilidad_real,  marker='o', linestyle='-',color='b')
plt.xlabel('Cantidad de Personas (k)')
plt.ylabel('Probabilidad Real')
plt.title('Paradoja del Cumpleaños')
plt.grid(True)
plt.xticks(range(1, 51, 2))
probabilidad_k_23 = calculoParadoja(23)

# Agregamos una flecha que muestre el resultado en k = 23
plt.annotate(f'P(k=23) = {probabilidad_k_23:.4f}', xy=(23, probabilidad_k_23), xytext=(28, 0.1),
             arrowprops=dict(facecolor='black', shrink=0.05))

# Ajustar el espacio entre los gráficos
plt.tight_layout()
# Mostrar el gráfico combinado
plt.show()

# Conclusión para el primer gráfico
conclusion_grafico1 = ["El primer gráfico muestra la probabilidad estimada de coincidencia de cumpleaños para diferentes tamaños de grupo (k).",
                       "La probabilidad aumenta a medida que el grupo crece, de acuerdo al valor que le asignemos a la semilla la misma puede cambiar cada vez que ejecutemosel código.",
                       "Para aproximarnos más al valor del grafico 2 debemos incrementar considerablemente el número de repeticiones, lo demostramos en el bloque siguiente."
                       ]

# Conclusión para el segundo gráfico
conclusion_grafico2 = "El segundo gráfico representa la probabilidad real de la Paradoja del Cumpleaños y muestra cómo la probabilidad de coincidencia de cumpleaños supera el 50% cuando k = 23."

print("CONCLUSIÓN")
for frase in conclusion_grafico1:
    print(frase)
print("")
print(conclusion_grafico2)

"""<h3>Probabilidad estimada de coincidencia con muestras en 100000</h3>
<i>Esta simulación demora un tiempo en correr.</i>

Observamos que al aumentar la cantidad de repeticiones, la curva de Probabilidad Estimada se asemeja mucho más a la curva de la Probabilidad Teórica, para mostrar exactamente cuánto procedemos a seleccionar para k=23 con flechas en el gráfico. Esto se debe a que, al incrementar el número de repeticiones, reducimos la influencia de la aleatoreidad, lo que nos permite obtener estimaciones más precisas. Esto se basa en  la Ley de los Grandes Números; a medida que el número de muestras(n) tiende hacia el infinito (n → ∞), la probabilidiad de que la media estimada se acerque a la media teórica es 1. Dicho de otro modo, la frecuencia relativa de probabilidad simulada tiende a converger a hacia la probabilidad real.
"""

# Ambas en mismo grafico superpuestas.
random.seed(95)
probabilidad_real = [calculoParadoja(x) for x in k_values]
probabilidades_estimadas = [estimar_probabilidad(k, 100000) for k in k_values]
probabilidad_estimada_k_23 = probabilidades_estimadas[22]
probabilidad_real_k_23 = calculoParadoja(23)
plt.figure(figsize=(10, 6))
plt.plot(k_values, probabilidades_estimadas, marker='o', linestyle='-', color='b', label='Probabilidad Estimada')
plt.plot(k_values, probabilidad_real, linestyle='--', color='r', label='Probabilidad Real')
plt.xlabel('Cantidad de Personas (k)')
plt.ylabel('Probabilidad')
plt.title('Comparación de Probabilidad Estimada y la Real del Cumpleaños')
plt.grid(True)
plt.legend()
plt.xticks(range(1, 51, 2))
plt.annotate(f'P(k=23) Estimada = {probabilidad_estimada_k_23:.4f}', xy=(23, probabilidad_estimada_k_23),
             xytext=(28, 0.35), arrowprops=dict(facecolor='blue', shrink=0.05))
plt.annotate(f'P(k=23) Real = {probabilidad_real_k_23:.4f}', xy=(23, probabilidad_real_k_23),
             xytext=(28, 0.25), arrowprops=dict(facecolor='red', shrink=0.05))

plt.show()